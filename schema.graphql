schema {
  query: Query
  mutation: Mutation
}

type Query {
  me: Person
  getPerson(id: ID!): Person

  getAllEvents(limit: Int, nextToken: String): EventConnection
  getEvents(groupId: ID!, limit: Int, nextToken: String): EventConnection
  getEvent(id: ID!): Event

  getGroups(limit: Int, nextToken: String): GroupConnection
  getGroup(id: ID!): Group

  getComments(eventId: ID!, limit: Int, nextToken: String): CommentConnection
  getMembers(groupId: ID!, limit: Int, nextToken: String): PersonConnection

  search(input: SearchInput!): SearchResult
}

type Mutation {
  signUp(input: SignUpInput!): Person

  addEvent(input: AddEventInput!): Event
  editEvent(input: EditEventInput!): Event
  cancelEvent(input: CancelEventInput!): Event
  deleteEvent(id: ID!): Boolean
  toggleStarEvent(id: ID!): Event

  createGroup(input: CreateGroupInput!): Group
  editGroup(input: EditGroupInput!): Group
  closeGroup(id: ID!): Group
  openGroup(id: ID!): Group
  deleteGroup(id: ID!): Boolean
  joinGroup(id: ID!): Group
  leaveGroup(id: ID!): Group

  addComment(input: AddCommentInput!): Comment
  deleteComment(id: ID!): Boolean
}

input SignUpInput {
  name: String!
  email: AWSEmail!
  pictureUrl: AWSURL
}

input AddCommentInput {
  content: String!
  replying: ID!
}

input CreateGroupInput {
  name: String!
  description: String
  privacy: GroupPrivacy!
}

input EditGroupInput {
  id: ID!
  name: String
  description: String
  privacy: GroupPrivacy
}

input AddEventInput {
  title: String!
  description: String
  location: Location
  start: AWSDateTime!
  end: AWSDateTime!
  allDay: Boolean!
  repeat: EventFrequency!
  type: EventType!
  groupId: ID!
}

input EditEventInput {
  id: ID!
  option: EditEventOption!
  payload: EditEventInputPayload!
}

input CancelEventInput {
  id: ID!
  option: EditEventOption!
}

input EditEventInputPayload {
  title: String
  description: String
  location: Location
  start: AWSDateTime
  end: AWSDateTime
  allDay: Boolean
  repeat: EventFrequency
  type: EventType
}

input SearchInput {
  query: String!
  target: SearchTarget
}

interface Node {
  id: ID!
}

type Person implements Node {
  id: ID!
  name: String!
  email: AWSEmail!
  pictureUrl: AWSURL
  eventsCount: Int
  groupsCount: Int
  events: [Event]
  groups: [Group]
  preference: UserPreference!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type UserPreference {
  adminComments: Boolean!
  membersComments: Boolean!
  repliesToMyComments: Boolean!
  visitorsComments: Boolean!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Event implements Node {
  id: ID!
  title: String!
  description: String
  location: Location
  start: AWSDateTime!
  end: AWSDateTime!
  status: EventStatus!
  starsCount: Int!
  commentsCount: Int!
  allDay: Boolean!
  isCancelled: Boolean!
  cancelled: [AWSDateTime]
  isAuthor: Boolean!
  repeat: EventFrequency!
  type: EventType!
  author: Person!
  comments: [Comment]
  group: Group!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Group implements Node {
  id: ID!
  name: String!
  description: String
  privacy: GroupPrivacy!
  pictureUrl: AWSURL
  isAdmin: Boolean!
  isPrivate: Boolean!
  isClosed: Boolean!
  isMember: Boolean!
  status: GroupStatus!
  admin: Person!
  membersCount: Int
  eventsCount: Int
  events: [Event]
  members: [Person]
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Comment implements Node {
  id: ID!
  content: String!
  replying: Comment
  isAuthor: Boolean!
  event: Event!
  author: Person!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type PersonConnection {
  people: [Person]
  nextToken: String
}

type GroupConnection {
  groups: [Group]
  nextToken: String
}

type EventConnection {
  events: [Event]
  nextToken: String
}

type CommentConnection {
  comments: [Comment]
  nextToken: String
}

type Location {
  address: String!
  longitude: Float
  latitude: Float
}

type SearchResult {
  events(limit: Int, nextToken: String): EventConnection
  groups(limit: Int, nextToken: String): GroupConnection
  people(limit: Int, nextToken: String): PersonConnection
}

enum EditEventOption {
  SINGLE
  ALL
}

enum EventStatus {
  PENDING
  ONGOING
  ENDED
  CANCELLED
}

enum EventFrequency {
  NEVER
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

enum EventType {
  NORMAL
  REMINDER
  TASK
}

enum GroupStatus {
  OPEN
  CLOSED
}

enum GroupPrivacy {
  PUBLIC
  PRIVATE
}

enum SearchTarget {
  EVENT
  GROUP
  PERSON
}